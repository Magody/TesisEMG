clc;
clear all;

seed_rng = 44;
%% Libs

addpath(genpath('LabEPN'));
addpath(genpath('utils'));

%% Parameters
fprintf("Parameters config\n");
verbose_level = 0;
RepTraining = 150;
RepTesting = 150;
list_users = [1]; % [1 8]; 1:306
window_size = 300;
stride = 30;
rangeDown = 1;
dir_data = 'C:\Users\Magody\Documents\GitHub\TesisEMG\Data\'; % '/home/magody/programming/MATLAB/tesis/Data/';
dit_data_out = dir_data + "preprocessing" + "/";
assignin('base','RepTraining',  RepTraining); % initial value

%% Generating orientation
randn('seed', seed_rng);
rand('seed', seed_rng);
fprintf("Generating orientation\n");
on = true;
off = false;
environment_options = struct();
environment_options.post_processing = on;
environment_options.randomGestures = off;
environment_options.noGestureDetection = on;
environment_options.rangeValues = 300;
environment_options.packetEMG = true;
prepare_environment(dir_data, verbose_level-1, environment_options);
Code_0(rangeDown, dir_data);
orientation      = evalin('base', 'orientation');
dataPacket = evalin('base','dataPacket');
num_users = length(list_users);
model_orientation = dit_data_out + "orientation" + "Win" + window_size + "Stride" + stride + ".mat";
save(model_orientation, "orientation");


%% Generating features
fprintf("Generating table of features\n");
randn('seed', seed_rng);
rand('seed', seed_rng);
t_begin = tic;

dataPacketSize = length(dataPacket);
        
for index_id_user=1:num_users
    user_folder = "user"+list_users(index_id_user);
    
    user_full_dir = dit_data_out + user_folder + "/";
    [~, ~, ~] = mkdir(user_folder);
    
    
    userData = loadSpecificUserByName(user_folder, dir_data);
    index_in_packet = getUserIndexInPacket(dataPacket, user_folder);
    assignin('base', 'userIndex', index_in_packet);
    assignin('base','index_user', index_in_packet-2);
    assignin('base','rangeDown', rangeDown);
    assignin('base','emgRepetition', rangeDown);
    
    energy_index = strcmp(orientation(:,1), userData.userInfo.name);
    rand_data=orientation{energy_index,6};
    
    
    part1 = cell([1, RepTraining]);
    
    for gesture_number=1:RepTraining
           
    
        emgRepetition = evalin('base','emgRepetition');
        
        user_gesture = userData.training{rand_data(emgRepetition),1};
        emg = user_gesture.emg;    
        emg_points = length(emg);
        assignin('base','WindowsSize',  window_size);
        assignin('base','Stride',  stride);

        num_windows = getNumberWindows(emg_points, window_size, stride, false);
        
        gesture_struct = user_gesture;
        gesture_struct.num_windows = num_windows;
        
        

        features_per_window = zeros([num_windows, 40]);
        
        for window=1:num_windows

            [~,~,Features_GT,~,~, ~, gestureName, ~, ~] = ...
                Code_1(orientation, dataPacketSize, RepTraining, verbose_level-1);
            % Features_GT.Properties.RowNames = {char(gestureName)};
            features_per_window(window, :) = table2array(Features_GT);
        end
        
        gesture_struct.features_per_window = features_per_window;
        
        part1{gesture_number} = gesture_struct;
    
    end
    
    part2 = cell([1, RepTraining]);
    
    for gesture_number=1:RepTraining
           
    
        emgRepetition = evalin('base','emgRepetition');
        
        user_gesture = userData.training{rand_data(emgRepetition),1};
        emg = user_gesture.emg;    
        emg_points = length(emg);
        assignin('base','WindowsSize',  window_size);
        assignin('base','Stride',  stride);

        num_windows = getNumberWindows(emg_points, window_size, stride, false);
        
        gesture_struct = user_gesture;
        gesture_struct.num_windows = num_windows;
        
        

        features_per_window = zeros([num_windows, 40]);
        
        for window=1:num_windows

            [~,~,Features_GT,~,~, ~, gestureName, ~, ~] = ...
                Code_1(orientation, dataPacketSize, RepTraining, verbose_level-1);
            % Features_GT.Properties.RowNames = {char(gestureName)};
            features_per_window(window, :) = table2array(Features_GT);
        end
        
        gesture_struct.features_per_window = features_per_window;
        
        part1{gesture_number} = gesture_struct;
    
    end
    
    userInfo = userData.userInfo;
    sync = userData.sync;
    
    model_name = user_full_dir + "userData" + list_users(index_id_user) +  "Features" + "Win" + window_size + "Stride" + stride + ".mat";
    save(model_name, "userInfo", "sync", "part1", "part2");
            
end




t_end = toc(t_begin);
fprintf("Elapsed time: %.4f [minutes]\n", t_end/60);

